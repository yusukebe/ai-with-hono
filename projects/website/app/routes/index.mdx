---
title: 'AI with Hono'
---

# AI with Hono

- January 21, 2026

## Me

- Yusuke Wada
- Web application developer
- Developer Advocate @Cloudflare
- A founder of Bokete
- Creator of Hono
- [https://github.com/yusukebe](https://github.com/yusukebe)

## Honoの現状

- 2021年12月から4年ちょっと
- [28.4K GitHub stars](https://github.com/honojs/hono)
- [5,000万ダウンロード / 月](https://npmtrends.com/hono)
- Used in many products

![SS](https://ss.yusukebe.com/ad763468673f1b88067f0ca67135996e53de677ca634834ac041f7235bcd3868.png)

![SS](https://ss.yusukebe.com/7ba89afc72af9a5b71127063aba0cfa08e07f35cc13dfa15c0dc03ae0033e588.png)

## 使ってるところ例

![May products](https://ss.yusukebe.com/496b2aa0bc3252163e69275b2c4f25bd7013e89e99c200fd3d3d228bbbd921c0.png)

## Cloudflare社内

- KV
- Email
- AI Search
- R2
- Containers
- Images
- Warp
- Browser Isolation
- Dashboard
- PubSub
- Workers AI
- Queues
- AI Gateway
- Workflows
- Access
- Stream
- Observability

## AI with Hono

- Honoを使ってAIをすることについて話します

## アジェンダ

1. Hono CLIによるAIへの取り組み
2. MCPをHonoが支える
3. HonoでAIアプリをつくる
4. AI時代にフレームワークは必要か？

# 1. Hono CLIによるAIへの取り組み

## Hono CLI

- 2025/10/18 Hono Conferenceで発表
- "CLI for Human and AI with Hono"
- `npm install @hono/cli`

## 全く新しいコンセプト

- `create-*`コマンドではない
- ただの開発ツール（サーバー・ビルド・デプロイ）ではない
- Viteのラッパーではない

## `hono`コマンド

```bash
hono --help
```

## 5つのサブコマンド

```bash
# Show help
hono --help

# Display documentation
hono docs

# Search documentation
hono search middleware

# Send request to Hono app
hono request

# Start server
hono serve

# Generate an optimized Hono app
hono optimize
```

## `hono docs`

```bash
hono docs [path]
hono docs /docs/api/context
```

## `hono search`

```bash
hono search <query>
hono search middleware
```

## AIが使うと⋯

![SS](https://ss.yusukebe.com/62e501dc564761cf23087898113a76819edbd0582192b92ec720dbd42be0a740.png)

## `hono request`

```bash
hono request [file]
hono request src/index.ts
```

## いくつかのオプション

```bash
hono request \
  -P /api/usrs \
  -X POST \
  -d '{"name":"Alice"}' \
  src/index.ts
```

## アプリのテストに便利

### サーバーを立ち上げる

```bash
wrangler dev
curl http://localhost:8787
```

### サーバーを立ち上げなくていい

```bash
hono request
```

## つまり⋯AIが使うと

1. `hono search` - ドキュメントを検索
2. `hono docs` - ドキュメントを読む
3. `hono request` - アプリをテストする

## CLAUDE.mdやAGENTS.mdに書くとよい

```
### Workflow

1. Search documentation: `hono search <query>`
2. Read relevant docs: `hono docs [path]`
3. Test implementation: `hono request [file]`
```

## `hono serve`

```bash
hono serve src/index.ts
```

`http://localhost:7070` でサーバーが立ち上げる

## `--use` オプション

```bash
hono serve \
  --use "logger()" \
  src/inidex.ts
```

## 複雑な例

```bash
hono serve \
  --use "logger" \
  --use "bashcAuth({username:'foo',password:'bar'})" \
  src/index.ts
```

## ファイルサーバー

```bash
hono serve \
  --use "serveStatic({root:'./'})"
```

## プロキシ

```bash
hono serve \
  --use '(c) => proxy(`https://ramen-api.dev${new URL(c.req.url).pathname}`)'
```

## `hono optimize`

```bash
hono optimize [entry]
```

## 最適化

- 対象のアプリに最適化された`Hono`を作ってくれる => ファイルサイズの削減
- ルーティング
- API削除
  - Hono - `route` / `mount` / `fire`
  - Context - `c.body` / `c.json` / `c.html` / `c.text` …
  - HonoRequest - `c.req.json()` / `c.req.formData()`…

## 例

```ts
import { Hono } from 'hono'

const app = new Hono()

app.get('/', async (c) => {
  return c.json({ message: 'Hello' })
})

app.get('/health', (c) => c.text('OK'))

export default app
```

## 結果

![SS](https://ss.yusukebe.com/c13c1795265a38cb7d37e169feb795c82f3d8ff80b7dda45e130d9e1f37afa32.png)

## おさらい

5つのサブコマンド

```bash
# Show help
hono --help

# Display documentation
hono docs

# Search documentation
hono search middleware

# Send request to Hono app
hono request

# Start server
hono serve

# Generate an optimized Hono app
hono optimize
```

## Workers Fetch

- `hono request`と同機能をCloudflare Workers向けに切り出したもの
- [https://github.com/yusukebe/workers-fetch](https://github.com/yusukebe/workers-fetch)

```bash
# GET request (auto-detects wrangler.json, wrangler.jsonc, or wrangler.toml)
workers-fetch

# With path
workers-fetch /api/users

# POST request
workers-fetch -X POST -H "Content-Type:application/json" -d '{"name":"test"}' /api/users

# Custom config file
workers-fetch -c wrangler.toml /api/test

# With timeout (5 seconds)
workers-fetch --timeout 5 /api/slow
```

## `wrangler run`?

![SS](https://ss.yusukebe.com/6494fb74be3d2f0ee10512c9d194878bc8e51278ffb456061acf9f0eaf6ddbcc.png)

[https://x.com/yusukebe/status/2011974518026485767/quotes](https://x.com/yusukebe/status/2011974518026485767/quotes)

## VS Code拡張

- Hono CLIを利用したVS Codeの拡張
- リクエスト、Watch、Debugができる

![SS](https://ss.yusukebe.com/ffd20735fc6c04263e450b382502d7a0367d998ab5715f4b090d5e5ec709925d.png)

## Skills

- Hono CLIを使ったAgent Skillを作る試み
- [https://github.com/yusukebe/hono-skill](https://github.com/yusukebe/hono-skill)

# 2. MCPをHonoが支える

## HonoとMCP

- HonoでMCPサーバーを作るのは有効である
  - MCPライブラリがHonoを使っている
  - HonoアプリでMCPサーバーを作る

## MCPライブラリがHonoを使っている

- [Mastra](https://github.com/mastra-ai/mastra)
- [MCP公式SDK](https://github.com/modelcontextprotocol/typescript-sdk)
- [OpenCode](https://github.com/anomalyco/opencode)

## MCP SDKでHonoが使われだした

- Examples
- `@modelcontextprotocol/hono` - hono
- `@modelcontextprotocol/node` - @hono/node-server

## MCP SDKの遷移

- v1ではNode.jsのRequest/Response APIに依存していた
- v2でWeb StandardのAPIをサポート

![SS](https://ss.yusukebe.com/c902502f9a2f0aa7da6cc7ce0ca062513beadda5d3179829a17e7d5b6d0f0d6d.png)

[https://github.com/modelcontextprotocol/typescript-sdk/issues/260](https://github.com/modelcontextprotocol/typescript-sdk/issues/260)

## 基本的なシンタックス

- Web Standardに対応したHTTPStreamable
- ステートレス・ステートフルも扱いやすい

```ts
const transport = new WebStandardStreamableHTTPServerTransport()

app.all('/mcp', async (c) => {
  return transport.handleRequest(c.req.raw)
})
```

## `@modelcontextprotocol/hono`

- パースしたボディを変数 `c.get('parsedBody')` で使えるように
- ホスト名でのバリデーションを可能に

```ts
import { McpServer, WebStandardStreamableHTTPServerTransport } from '@modelcontextprotocol/server'
import { createMcpHonoApp } from '@modelcontextprotocol/hono'

const server = new McpServer({ name: 'my-server', version: '1.0.0' })
const transport = new WebStandardStreamableHTTPServerTransport({ sessionIdGenerator: undefined })
await server.connect(transport)

const app = createMcpHonoApp()
app.all('/mcp', (c) => {
  return transport.handleRequest(c.req.raw, { parsedBody: c.get('parsedBody') })
})
```

## `@modelcontextprotocol/node`

- Web StandardsのAPIとNode.jsのAPIの変換に使われている
- `getRequestListener`はNode.jsの`req` / `res`を受け取る。`req`をWeb Standardsの`Request`に変換。ハンドラに渡す。返却された`Response`を`res`に変換する。

```ts
// https://github.com/modelcontextprotocol/typescript-sdk/blob/main/packages/middleware/node/src/streamableHttp.ts
import { getRequestListener } from '@hono/node-server';

//...

async handleRequest (
  req: IncomingMessage & { auth?: AuthInfo },
  res: ServerResponse,
  parsedBody?: unknown
): Promise<void> {
  // Store context for this request to pass through auth and parsedBody
  // We need to intercept the request creation to attach this context
  const authInfo = req.auth

  // Create a custom handler that includes our context
  // overrideGlobalObjects: false prevents Hono from overwriting global Response, which would
  // break frameworks like Next.js whose response classes extend the native Response
  const handler = getRequestListener(
    async (webRequest: Request) => {
      return this._webStandardTransport.handleRequest(webRequest, {
        authInfo,
        parsedBody
      })
    },
    { overrideGlobalObjects: false }
  )

  // Delegate to the request listener which handles all the Node.js <-> Web Standard conversion
  // including proper SSE streaming support
  await handler(req, res)
}
```

## それまでのアプローチ

- CloudflareのAgents SDK - `agents/mcp`を使う
- `@hono/mcp`を使う

## `@hono/mcp`

```ts
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StreamableHTTPTransport } from '@hono/mcp'
import { Hono } from 'hono'
import { mcpServer } from './mcp-server'

const app = new Hono()

// Initialize the transport
const transport = new StreamableHTTPTransport()

app.all('/mcp', async (c) => {
  if (!mcpServer.isConnected()) {
    // Connect the mcp with the transport
    await mcpServer.connect(transport)
  }

  return transport.handleRequest(c)
})
```

## これからはMCP SDKでできる

pkg.pr.newのバージョンを使う:

```bash
bun add https://pkg.pr.new/modelcontextprotocol/typescript-sdk/@modelcontextprotocol/server@1326
```

`mcp-server.ts`:

```ts
// mcp-server.ts
import { McpServer } from '@modelcontextprotocol/server'
import * as z from 'zod/v4'

export const mcpServer = new McpServer({
  name: 'simple-server',
  version: '0.0.1'
})

mcpServer.registerTool(
  'add',
  {
    title: 'Add a to b',
    inputSchema: { a: z.number(), b: z.number() }
  },
  async ({ a, b }) => {
    return {
      content: [{ type: 'text', text: `${a + b}` }]
    }
  }
)
```

`index.ts`:

```ts
// index.ts
import { Hono } from 'hono'
import { WebStandardStreamableHTTPServerTransport } from '@modelcontextprotocol/server'
import { mcpServer } from './mcp-server'

const app = new Hono()

const transport = new WebStandardStreamableHTTPServerTransport()

app.all('/mcp', async (c) => {
  if (!mcpServer.isConnected()) {
    await mcpServer.connect(transport)
  }
  return transport.handleRequest(c.req.raw)
})

export default app
```

インスペクタ:

```bash
DANGEROUSLY_OMIT_AUTH=true npx @modelcontextprotocol/inspector
```

## MCP Server for Hono

- Honoのルーティングを書くとMCPの定義がされて、リモートMCPサーバーになるという試み
- [https://github.com/mattzcarey/hono-mcp-server](https://github.com/mattzcarey/hono-mcp-server)

```ts
import { Hono } from 'hono'
import { z } from 'zod'
import { mcp, registerTool } from 'hono-mcp-server'

const app = new Hono()

app.get('/', (c) => {
  return c.json({ message: 'Hello, MCP Server!' })
})
app.post(
  '/hello',
  registerTool({
    description: 'Say hello',
    inputSchema: {
      name: z.string().describe('Your name')
    }
  }),
  (c) => {
    const { name } = c.req.valid('json') // Typed!
    return c.json({ message: `Hello ${name}!` })
  }
)

export default mcp(app, {
  name: 'Simple MCP',
  version: '1.0.0'
})
```

![hono-mcp-server](https://ss.yusukebe.com/dddd6f9215dc4f2e70b692033f8eebcf1af93ea9e346938e3a14cfb41208d68e.png)

# 3. HonoでAIアプリをつくる

## HonoでAIアプリをつくろう

- LLM etc.を叩く
  - Workers AI
  - 外部API
- レスポンスをストリーミングで表示する

## Workers AIを使う

- AIモデルを叩くにはWorkers AIが簡単
- [https://developers.cloudflare.com/workers-ai/](https://developers.cloudflare.com/workers-ai/)

```ts
import { Hono } from 'hono'

const app = new Hono<{
  Bindings: CloudflareBindings
}>()

app.get('/', async (c) => {
  const stream = await c.env.AI.run('@cf/meta/llama-3.3-70b-instruct-fp8-fast', {
    messages: [
      { role: 'system', content: 'You are a ramen master' },
      {
        role: 'user',
        content: 'What is the tonkotsu ramen?'
      }
    ],
    stream: true
  })
  return c.body(stream, 200, {
    'Content-Type': 'text/event-stream'
  })
})

export default app
```

クライアントの実装:

```ts
import { stream } from 'fetch-event-stream'
import { stdout } from 'node:process'

const events = await stream('http://localhost:8787')

for await (let event of events) {
  if (event.data) {
    try {
      const data = JSON.parse(event.data)
      stdout.write(data.response)
    } catch {}
  }
}
```

## その他のAPIも叩ける

- OpenAI
- Claude
- [Replicate](https://replicate.com/)
- etc.

## チャットアプリの例

- 途中まで作ってあとはAIにやってもらう作戦

## 手順

- Cloudflare + Viteプロジェクトの作成
- LLMを叩く
- スキーマ・バリデーション
- SSRレンダリング
- クライアント

## Cloudflare + Viteプロジェクトの作成

Create-honoを使い、`cloudflare-workers+vite`を選ぶ:

```bash
bun create hono@latest my-chat
```

## LLMを叩く

`wrangler.jsonc`のBindingsにAIを足す:

```json
{
  "$schema": "node_modules/wrangler/config-schema.json",
  "name": "my-chat",
  "compatibility_date": "2025-08-03",
  "main": "./src/index.tsx",
  "ai": {
    "binding": "AI",
    "remote": true
  }
}
```

型定義を書き出す:

```bash
bun run cf-typegen
```

ジェネリクスに渡す:

```ts
// src/index.tsx
const app = new Hono<{ Bindings: CloudflareBindings }>()
```

Workers AIのLLMを叩いてストリームを返す:

```ts
// src/index.tsx
app.get('/stream', async (c) => {
  const stream = await c.env.AI.run('@cf/meta/llama-3.3-70b-instruct-fp8-fast', {
    messages: [{ role: 'user', content: 'Hello!' }],
    stream: true
  })
  return c.body(stream, 200, {
    'Content-Type': 'text/event-stream'
  })
})
```

## スキーマ・バリデーション

`messages`を受け取るためのスキーマ定義:

```ts
// src/index.tsx
import * as z from 'zod'

// ...

const schema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(['system', 'user', 'assistant']),
      content: z.string()
    })
  )
})
```

POSTで受け取り、バリデーションする:

```ts
// src/index.tsx
import { zValidator } from '@hono/zod-validator'

// ...

app.post('/stream', zValidator('json', schema), async (c) => {
  const data = c.req.valid('json')
  const stream = await c.env.AI.run('@cf/meta/llama-3.3-70b-instruct-fp8-fast', {
    messages: data.messages,
    stream: true
  })
  return c.body(stream, 200, {
    'Content-Type': 'text/event-stream'
  })
})
```

## SSRレンダリング

トップページをSSRで作る:

```tsx
// src/index.tsx
app.get('/', (c) => {
  return c.render(
    <div id="chat-container">
      <div id="messages"></div>
      <form id="chat-form">
        <textarea id="input" placeholder="Type a message..." rows={3}></textarea>
        <button type="submit">Send</button>
      </form>
    </div>
  )
})
```

## クライアント

vite-ssr-componentsから`Script`をインポートしてクライアントファイルを指定:

```tsx
// src/renderer.tsx
import { jsxRenderer } from 'hono/jsx-renderer'
import { Script, Link, ViteClient } from 'vite-ssr-components/hono'

export const renderer = jsxRenderer(
  ({ children }) => {
    return (
      <html>
        <head>
          <ViteClient />
          <Script src="/src/client.ts" />
          <Link href="/src/style.css" rel="stylesheet" />
        </head>
        <body>{children}</body>
      </html>
    )
  },
  { stream: true }
)
```

`client.ts`を作成する:

```ts
// src/client.ts
/// <reference lib="dom" />
/// <reference lib="dom.iterable" />
```

ストリームのパースに`fetch-event-stream`を使うと便利かも:

```ts
// src/client.ts
import { events } from 'fetch-event-stream'
```

## AIに任せる

あとはAIに任せる。

# 4. AI時代にフレームワークは必要か？

## AI時代のフレームワーク

- そもそもAI時代にHonoは必要か？
- プリミティブな部品だけを組み合わせてアプリを作れる？
- だからこそフレームワークは必要？

## HonoとAIのベストプラクティス

- LLMはもうHonoのことを結構知ってる
- 必要に応じてSkillを使う
  - 特にCloudflareとかプラットフォームの知識は古いままだったりする
- 途中まで作ってあとはAIに任せるのあり
- 設定等のつまずきはAIが解決してくれる

## Developers Summitの宣伝

- 2月20日 17:00 ～ 17:40
- Hono開発者とユーザーが語る「AI時代にフレームワークは必要なのか？」
- [https://event.shoeisha.jp/devsumi/20260218/session/6495](https://event.shoeisha.jp/devsumi/20260218/session/6495)

![Developers Summit](https://ss.yusukebe.com/6c768f840c486b4e2613e65c268b8f1c9ce2d76008ac95c8c15a17e6e43e4360.png)

# 余談 - このWebページもHonoで出来てる

- HonoX
- SSG
- MDX
- Frontmatter
- Shiki

```
.
├── app
│   ├── client.ts
│   ├── global.d.ts
│   ├── routes
│   │   ├── _404.tsx
│   │   ├── _error.tsx
│   │   ├── _renderer.tsx
│   │   └── index.mdx
│   ├── server.ts
│   └── style.css
├── package.json
├── public
│   └── favicon.ico
├── tsconfig.json
├── vite.config.ts
└── wrangler.jsonc
```

# まとめ

Honoを使ってAIをすることについて話してきました。

1. Hono CLIによるAIへの取り組み
2. MCPをHonoが支える
3. HonoでAIアプリをつくる
4. AI時代にフレームワークは必要か？
